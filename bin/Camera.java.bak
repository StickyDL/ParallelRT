import javax.vecmath.Point3d;
import javax.vecmath.Vector3d;
import java.awt.image.BufferedImage;
import java.awt.image.WritableRaster;
import java.awt.Frame;
import java.awt.Canvas;
import java.awt.Dimension;
import java.awt.Graphics;

public class Camera {

	private final double XMIN = -0.5;
	private final double XMAX = 0.5;
	private final double YMIN = 0.5;
	private final double YMAX = 1.5;
	private final int XRES = 500;
	private final int YRES = 500;
	private final double Z = 0.5;
	//private final double Z = -1.0; //Testing Z Value
	//private final double YMIN = -0.5; //Testing YMIN Value
	//private final double YMAX = 0.5; //Testing YMAX Value

	static BufferedImage image;

	private int pixelNum = 0;
	private double deltaY = (YMAX - YMIN) / YRES;
	private double deltaX = (XMAX - XMIN) / XRES;
	private double[] pixelArray;
	private double BACKGRD_RED = 0;
	private double BACKGRD_GREEN = 50;
	private double BACKGRD_BLUE = 255;

	Point3d position;
	Point3d lookat;
	Vector3d up;

	public Camera(Point3d position, Point3d lookat, Vector3d up){

		this.position = position;
		this.lookat = lookat;
		this.up = up;

		image = new BufferedImage(XRES, YRES, BufferedImage.TYPE_INT_RGB);
		pixelArray = new double[XRES*YRES*3];

	}

	public void render(World w) {

		Frame frame = new Frame( "Ray Tracer - CG2" );
		WritableRaster raster = image.getRaster();

		double red = 0;
		double green = 0;
		double blue = 0;
		
		//Vector3d directVect = new Vector3d(0.0, 0.0, -1.0);
		//Vector3d testerVect = new Vector3d(-0.1, 0.3, -2.0);
		//Ray directRay = new Ray(this.position, testerVect);
		//Point3d directPoint = w.objectList.get(0).intersect(directRay);
		//System.out.println(directPoint.x + ", " + directPoint.y + ", " + directPoint.z);
		Vector3d initial = new Vector3d(-0.75, -3.95, -0.9);
		initial.normalize();
		Ray tester = new Ray(w.light.position, initial);
		Point3d testPoint = w.objectList.get(0).intersect(tester);
		//System.out.println(testPoint.x + ", " + testPoint.y + ", " + testPoint.z);

		for(double y = YMAX; y > YMIN; y = y - deltaY) {

			for( double x = XMIN; x < XMAX; x = x + deltaX) {

				if(pixelNum < pixelArray.length) {

					Ray rtRay = new Ray( this.position, new Vector3d(x-(this.position.x), y-(this.position.y), Z-(this.position.z)));
					Point3d iPoint = new Point3d(Double.MAX_VALUE, Double.MAX_VALUE, Double.MAX_VALUE);

					for( int i=0; i<w.objectList.size(); i++) {

						//red = w.objectList.get(i).ambcolor.r;
						//blue = w.objectList.get(i).ambcolor.b;
						//green = w.objectList.get(i).ambcolor.g;

						//calculate intersection
						//Checkpoint 2
						//System.out.println("(" + rtRay.direction.x + "," + rtRay.direction.y + "," + rtRay.direction.z + ")");
						Point3d inter = w.objectList.get(i).intersect(rtRay);

						if( inter != null) {
							if( this.position.distance(inter) < this.position.distance(iPoint)) {

								iPoint = inter;
								
								//Retrieve object constants
								//Checkpoint 3
								double ka = w.objectList.get(i).ka;
								double kd = w.objectList.get(i).kd;
								double ks = w.objectList.get(i).ks;
								double ke = w.objectList.get(i).ke;
								
								//Checkpoint 4 - Get color. If object has a shader, returns color from that.
								Color objectColor = w.objectList.get(i).getColor(iPoint);
								red = objectColor.r;
								green = objectColor.g;
								blue = objectColor.b;
								
								//Calculate Ambient Light
								Color light = new Color(ka * ((w.ambRed * red)/255), ka * ((w.ambGreen *green)/255), 
										ka * ((w.ambBlue * blue)/255));
								
								
								//create ray from light source to point of intersection
								Ray shadowRay = new Ray(iPoint, new Vector3d(w.light.position.x - iPoint.x, 
										w.light.position.y - iPoint.y, w.light.position.z - iPoint.z));
								
								//check to see if shadow ray intersects any object.
								Point3d lightInter = null;
								/*
								for( int j=0; j<w.objectList.size(); j++) {
									if( i != j ) {
										Point3d shadowInter = w.objectList.get(j).intersect(shadowRay);
										if( shadowInter != null && shadowInter.distance(w.light.position) < iPoint.distance(w.light.position)) {
											lightInter = new Point3d();
											System.out.println("here?");
											light.r = 0.0;
											light.g = 0.0;
											light.b = 0.0;
										}
									}
								}
								*/
								for( int j=0; j<w.objectList.size(); j++) {
									if (i != j) {
										Point3d shadowInter = w.objectList.get(i).intersect(shadowRay);
										if(shadowInter != null && (iPoint.distance(w.light.position) > shadowInter.distance(w.light.position))) {
											lightInter = shadowInter;
										}
									}
								}
								
								if(lightInter == null){
									//calculating N, V and S
									Vector3d N = w.objectList.get(i).normal;
									Vector3d V = new Vector3d((this.position.x - iPoint.x), (this.position.y - iPoint.y),
											(this.position.z - iPoint.z));
									Vector3d S = new Vector3d(w.light.position.x-(iPoint.x), 
											w.light.position.y-(iPoint.y), w.light.position.z-(iPoint.z));
									
									//Normalizing vectors
									N.normalize();
									V.normalize();
									S.normalize();
									
									//calculating S dot product N
									double sdotn = S.dot(N);
									
									//setting diffuse color
									//Color diffuseColor = new Color( kd * ((w.light.red * red *sdotn)/255), kd * ((w.light.green *green * sdotn)/255), 
									//		kd *((w.light.blue * blue * sdotn)/255));
									
									Color diffuseColor = new Color( (kd * sdotn) * ((w.light.red * red )/255), (kd * sdotn) * ((w.light.green *green)/255), 
											(kd * sdotn) * ((w.light.blue * blue)/255));
									
									light.r += diffuseColor.r;
									light.g += diffuseColor.g;
									light.b += diffuseColor.b;
									
									//System.out.println("Ambient + Diffuse Light:");
									//System.out.println("Red: " + light.r);
									//System.out.println("Green: " + light.g);
									//System.out.println("Blue: " + light.b);
									
									//calculate 2 *(S dot N)
									
									double fraction = (2*sdotn);
									
									Vector3d newN = new Vector3d(N.x * fraction, N.y * fraction, N.z * fraction);
									Vector3d R = new Vector3d(S.x - newN.x, S.y - newN.y, S.z - newN.z);
									R.normalize();
									
									double sdotr = V.dot(R);
										
									Color specColor = new Color( (ks * Math.pow(sdotr, ke)) * ((w.light.red * w.objectList.get(i).speccolor.r)/255), (ks * Math.pow(sdotr, ke)) *  ((w.light.green * w.objectList.get(i).speccolor.g)/255), 
											(ks * Math.pow(sdotr, ke)) * ((w.light.blue * w.objectList.get(i).speccolor.b)/255));
									
									light.r += specColor.r;
									light.g += specColor.g;
									light.b += specColor.b;
									
								}
								
								else {
									light.r = 0.0;
									light.g = 0.0;
									light.b = 0.0;
								}

								pixelArray[pixelNum] = light.r;
								pixelArray[pixelNum+1] = light.g;
								pixelArray[pixelNum+2] = light.b;

							}

						} else if(i == 0) {

							pixelArray[pixelNum] = BACKGRD_RED;
							pixelArray[pixelNum+1] = BACKGRD_GREEN;
							pixelArray[pixelNum+2] = BACKGRD_BLUE;

						}

					}

					pixelNum += 3;

				}

			}

		}

		raster.setPixels(0, 0, XRES, YRES, pixelArray);
		frame.add(new Painter());
		frame.setSize(new Dimension(XRES+20, YRES+44));
		frame.setVisible(true);

	}

}

class Painter extends Canvas {

	public void paint(Graphics g) {
		g.drawImage(Camera.image, 0, 0, null);
	}

}   